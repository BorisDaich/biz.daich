package biz.daich.common.tools.generation;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URL;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Random;

import org.apache.commons.lang3.RandomStringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.common.collect.Lists;
import com.google.common.io.Resources;

import biz.daich.common.exceptions.InternalServerException;

/**
 * Tools to work with random objects useful for testing
 *
 * @author Boris Daich
 *         <P>
 *         deprecated - Use Podam http://mtedone.github.io/podam/index.html - works better does the same
 */

public class RandomObjectsTools
{
    private static final Logger l                      = LogManager.getLogger(RandomObjectsTools.class.getName());

    /**
     * static global math.random instance for convenience
     */
    public static final Random  RANDOM                 = new Random();

    /**
     * get a random 200x200 picture from the http://lorempixel.com/200/200/
     *
     * @return a byte[] of the picture retrieved from web
     */
    public static byte[] getRandomPicture()
    {
        String randPictureUrl = "http://lorempixel.com/200/200/";
        byte[] byteArray1;
        try
        {
            byteArray1 = Resources.toByteArray(new URL(randPictureUrl));
        }
        catch (Exception e)
        {
            l.error("getRandomPicture(String)", e); //$NON-NLS-1$
            throw new InternalServerException(e);
        }
        return byteArray1;
    }

    /**
     * random alphanumeric String of 10
     *
     * @return generated String
     */
    public static String genStr()
    {
        return RandomStringUtils.randomAlphanumeric(10);
    }

    /**
     * @return generated int range not limited
     */
    public static int genInt()
    {
        return RANDOM.nextInt();
    }

    /**
     * @return generated double 0..1
     */
    public static double genDouble()
    {
        return RANDOM.nextDouble();
    }

    /**
     * @return Date - Gaussian distributed date in the +12 hours -12 hours from now.
     */
    public static Date genDate()
    {
        long time = System.currentTimeMillis() + (long) (RANDOM.nextGaussian() * (long) (3600 * 24 * 1000));
        return new Date(time);
    }

    /**
     * generates date that is =-30 days from now. Time always 00:00
     *
     * @return generated Date
     */
    public static Date genRandDate()
    {
        Calendar cal = Calendar.getInstance();

        {
            cal.set(Calendar.HOUR, 0);
            cal.set(Calendar.MINUTE, 0);
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);
        }
        cal.add(Calendar.DATE, RANDOM.nextInt(60) - 30);
        return cal.getTime();
    }

    /**
     * Those are the Classes considered basic and values are generated by the Object genRandBasicClassValue(Class&lt;?&gt; type)
     */
    public static final Collection<Class<?>> basicClasses = Lists.newArrayList(boolean.class, //
                                                                               Boolean.class, //
                                                                               String.class, //
                                                                               double.class, //
                                                                               int.class, //
                                                                               Date.class, //
                                                                               BigDecimal.class);

    /**
     * @param type
     *            - Class out of the list basicClasses
     * @return generated value of type type
     *         Else will return null
     */
    public static Object genRandBasicClassValue(Class<?> type)
    {
        if (basicClasses.contains(type))
        {
            if (boolean.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type))
            {
                return RANDOM.nextBoolean();
            }
            else
                if (String.class.isAssignableFrom(type))
                {
                    return genStr();
                }
                else
                    if (double.class.isAssignableFrom(type))
                    {
                        return genDouble() * 10 + 1;
                    }
                    else
                        if (int.class.isAssignableFrom(type))
                        {
                            return genInt() + 1;
                        }
                        else
                            if (Date.class.isAssignableFrom(type))
                            {
                                return genRandDate();
                            }
                            else
                                if (BigDecimal.class.isAssignableFrom(type))
                                { //
                                    return new BigDecimal(RANDOM.nextDouble() * 500).setScale(2, RoundingMode.HALF_UP); //
                                }
        }
        return null;
    }

}
